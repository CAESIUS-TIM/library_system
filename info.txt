"""
1.测试字符串内的模式：
例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
2.替换文本：
可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
3.基于模式匹配从字符串中提取子字符串：
可以查找文档内或输入域内特定的文本。
"""
import re

# ? 0 or 1 
## data(\w)?\.dat

# * 0 or More
## data.*\.dat

# ^ begin
# [0-9]
# + 1 or More
# abc
# $ end
## ^[0-9]+abc$

# [a-z0-9_-] [a-z] [0-9] [_]
# {3,15} from 3 to 15
## ^[a-z0-9_-]{3,15}$

# ---- ----
# .
# []
# ^
# $
# \( \) 
# \{ \}
# ?
# +
# |
# ()

# ? 0 or 1
# * 0 or More
# + 1 or More

# -- 非打印字符 --
# \cx:: x [a-zA-Z]: Ctrl-x; else: 'c'
# \f:: 换页符 \x0c \cL
# \n:: 换行符 \x0a \cJ
# \r:: 回车符
# \s:: [任何空白字符] [\f\n\r\t\v] PS: Unicode 正则表达式会匹配全角空格符
# \S:: [任何非空白字符] [^ \f\n\r\t\v]
# \t:: 制表符 \x09 \cI
# \v:: 垂直制表符 \x0b \cK

# -- 特殊字符 --
# \$:: $ \^:: ^ (以此类推)
# $:: 字符串结尾 if re.M (re.MULTILINE): '\n' or '\r'
# ^:: 字符串开始，除非在方括号表达式中使用(<=> not, !, ¬)
# .:: every char besides '\n'
# ?:: 0 or 1 || 指明一个非贪婪限定符 | {0,1}
# *:: 0 or More || 贪婪限定符       | {0,}
# +:: 1 or More || 贪婪限定符       | {1,}
# \
# |:: 指明两项之间的一个选择
# ():: 标记一个子表达式的开始和结束位置(子表达式可以获取供以后使用)
# []:: 标记一个中括号表达式的开始
# {}:: 标记限定符表达式的开始
## <123>123>
### <.*>:: <123>123>
### <.*>>:: <123>

# -- {num & ,} 贪婪限定符 --
# {n} n
# {n,} [n,∞)
# {n,m} [n,m]

# -- 定位符 -- PS: 不能将限定符与定位符一起使用 error: ^*
# ^ $
# \b 匹配一个单词边界，即字与空格间的位置
# \B 非单词边界匹配

# -- 选择 --
"""
用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。
但用圆括号会有一个副作用，使相关的匹配会被缓存，
此时可用?:放在第一个选项前来消除这种副作用。
其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，
这两个还有更多的含义，前者为正向预查，
在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，
后者为负向预查，
在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。
"""

# -- 反向引用 --
# 反向引用的最简单的、最有用的应用之一，
# 是提供查找文本中两个相同的相邻单词的匹配项的能力。
# Is is the cost of of gasoline going up up?
# /\b([a-z]+) \1\b/ig
# \1 指定第一个子匹配项
# re.I (re.IGNORECASE) | g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配
## Is is,of of,up up
# match?
# print(re.search("{\b([a-z]+) \1\b}","Is is the cost of of gasoline going up up?",re.I))

# string = "http://www.runoob.com:80/html/html-tutorial.html"
# /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/
# c = re.compile("\w+")
# for i in re
#     print(,end='')
#     print("<br>",end='')

# http://www.runoob.com:80/html/html-tutorial.html
# http
# www.runoob.com
# :80
# /html/html-tutorial.html

# -- expression --
# 限定符 + 非贪婪限定符:: (*,+,?,{n},{n,},{n,m})?
# (pattern):: 获取匹配
# (?:pattern):: 非获取匹配 eg: industr(?y|ies)
# (?=pattern):: 正向肯定预查(look ahead positive assert)
# eg: "Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。
# PS: 预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
# (?!pattern):: 正向否定预查(negative assert)
# eg: "Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。
# the same PS [大意：咱就蹭蹭，咱不进去]
# 方向相反
# (?<=pattern):: eg: (?<=95|98|NT|2000)Windows
# (?<=pattern)
# x|y [xyz] [^xyz] [a-z] [^a-z]
# 大写即 add '^' 即补集 : \d数字 \D非数字
# \d数字 \s空白字符 \w字母数字下划线 [A-za-x_]
# \xn:'\x41'='A' \num::num正整数,对[所获取的匹配]的引用 
# eg:(.)\1 => 匹配两个连续的相同字符
# \un::unicode eg: '\u00A9'=版权符号 '©'
# \n \nm \nml 标识一个八进制转义值 或 一个向后引用 或 Error
# # 为什么是Error?
# c=re.compile('\\\\') 
# print(c.match(r"\999"))
# # <re.Match object; span=(0, 1), match='\\'>

# -- 运算符优先级 --
# \                        |转义符
# (), (?:), (?=), []       |圆括号和方括号
# *, +, ?, {n}, {n,}, {n,m}|限定符
# ^, $, \任何元字符、任何字符|定位点和序列（即：位置和顺序）
# |                        |替换，"或"操作

# -- 匹配规则 --
# -基本模式匹配
# -字符簇 []
# 该转义的加'\'
# eg: [^\\\/\^] 除了'\','/','^'
# 相对顺序
# eg: [A-Za-z]+[0-9]+ => 'x1', 'y2'
# PS: PHP contain [[:string:]]
# Python, 'Nope!'
# -确定重复出现 {num & ,}
# ^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
# ^[1-9][0-9]{0,}$        // 所有的正整数 
# ^\-{0,1}[0-9]{1,}$      // 所有的整数 
# ^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
it=re.finditer('aa','aaaa')
for i in it:
    print(i)
## <re.Match object; span=(0, 2), match='aa'>
## <re.Match object; span=(2, 4), match='aa'>
## 贪心 而非 dp